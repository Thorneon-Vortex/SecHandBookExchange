# 《数据库系统原理》大作业 - 系统实现报告

## 题目名称：校园二手书交易与分享平台

---

## 一、数据库基本表的定义

### 1. 用户表 (User)

```sql
CREATE TABLE `user` (
  `user_id` INT NOT NULL AUTO_INCREMENT COMMENT '用户ID, 主键',
  `student_id` VARCHAR(20) NOT NULL COMMENT '学号, 唯一',
  `nickname` VARCHAR(50) NOT NULL COMMENT '昵称',
  `password` VARCHAR(255) NOT NULL COMMENT '密码 (加密存储)',
  `register_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间',
  `contact_info` VARCHAR(100) NULL COMMENT '联系方式',
  `credit_score` INT NOT NULL DEFAULT 100 COMMENT '信誉积分',
  PRIMARY KEY (`user_id`),
  UNIQUE INDEX `uk_student_id` (`student_id` ASC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

### 2. 书籍分类表 (Category)

```sql
CREATE TABLE `category` (
  `category_id` INT NOT NULL AUTO_INCREMENT COMMENT '分类ID, 主键',
  `category_name` VARCHAR(50) NOT NULL COMMENT '分类名称',
  PRIMARY KEY (`category_id`),
  UNIQUE INDEX `uk_category_name` (`category_name` ASC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='书籍分类表';
```

### 3. 书籍信息表 (Book)

```sql
CREATE TABLE `book` (
  `book_id` INT NOT NULL AUTO_INCREMENT COMMENT '书籍ID, 主键',
  `isbn` VARCHAR(20) NOT NULL COMMENT 'ISBN, 唯一',
  `title` VARCHAR(255) NOT NULL COMMENT '书名',
  `author` VARCHAR(100) NOT NULL COMMENT '作者',
  `publisher` VARCHAR(100) NULL COMMENT '出版社',
  `publication_year` VARCHAR(10) NULL COMMENT '出版年份',
  `cover_image_url` VARCHAR(512) NULL COMMENT '封面图片URL',
  PRIMARY KEY (`book_id`),
  UNIQUE INDEX `uk_isbn` (`isbn` ASC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='书籍基本信息表';
```

### 4. 书籍与分类关联表 (Book_Category)

```sql
CREATE TABLE `book_category` (
  `book_id` INT NOT NULL COMMENT '书籍ID, 外键',
  `category_id` INT NOT NULL COMMENT '分类ID, 外键',
  PRIMARY KEY (`book_id`, `category_id`),
  INDEX `fk_book_category_category_idx` (`category_id` ASC),
  CONSTRAINT `fk_book_category_book`
    FOREIGN KEY (`book_id`) REFERENCES `book` (`book_id`)
    ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_book_category_category`
    FOREIGN KEY (`category_id`) REFERENCES `category` (`category_id`)
    ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='书籍与分类的关联表';
```

### 5. 发布信息表 (Listing)

```sql
CREATE TABLE `listing` (
  `listing_id` INT NOT NULL AUTO_INCREMENT COMMENT '发布ID, 主键',
  `seller_id` INT NOT NULL COMMENT '发布者ID, 外键',
  `book_id` INT NOT NULL COMMENT '书籍ID, 外键',
  `price` DECIMAL(10,2) NOT NULL COMMENT '价格',
  `condition_desc` VARCHAR(20) NOT NULL COMMENT '新旧程度',
  `listing_type` ENUM('出售', '赠送') NOT NULL COMMENT '发布类型',
  `status` ENUM('在售', '已预定', '已售出', '已下架') NOT NULL DEFAULT '在售' COMMENT '状态',
  `post_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '发布时间',
  `description` TEXT NULL COMMENT '详细描述',
  PRIMARY KEY (`listing_id`),
  INDEX `fk_listing_user_idx` (`seller_id` ASC),
  INDEX `fk_listing_book_idx` (`book_id` ASC),
  CONSTRAINT `fk_listing_user`
    FOREIGN KEY (`seller_id`) REFERENCES `user` (`user_id`)
    ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_listing_book`
    FOREIGN KEY (`book_id`) REFERENCES `book` (`book_id`)
    ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='书籍发布信息表';
```

### 6. 订单表 (Orders)

```sql
CREATE TABLE `orders` (
  `order_id` INT NOT NULL AUTO_INCREMENT COMMENT '订单ID, 主键',
  `listing_id` INT NOT NULL COMMENT '发布ID, 外键',
  `buyer_id` INT NOT NULL COMMENT '购买者ID, 外键',
  `order_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '下单时间',
  `order_status` ENUM('待确认', '已完成', '已取消') NOT NULL DEFAULT '待确认' COMMENT '订单状态',
  `transaction_price` DECIMAL(10,2) NOT NULL COMMENT '交易价格',
  PRIMARY KEY (`order_id`),
  INDEX `fk_order_listing_idx` (`listing_id` ASC),
  INDEX `fk_order_user_idx` (`buyer_id` ASC),
  CONSTRAINT `fk_order_listing`
    FOREIGN KEY (`listing_id`) REFERENCES `listing` (`listing_id`)
    ON DELETE RESTRICT ON UPDATE CASCADE,
  CONSTRAINT `fk_order_user`
    FOREIGN KEY (`buyer_id`) REFERENCES `user` (`user_id`)
    ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='交易订单表';
```

### 7. 评论表 (Comment)

```sql
CREATE TABLE `comment` (
  `comment_id` INT NOT NULL AUTO_INCREMENT COMMENT '评论ID, 主键',
  `listing_id` INT NOT NULL COMMENT '发布ID, 外键',
  `user_id` INT NOT NULL COMMENT '评论者ID, 外键',
  `content` TEXT NOT NULL COMMENT '评论内容',
  `comment_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '评论时间',
  PRIMARY KEY (`comment_id`),
  INDEX `fk_comment_listing_idx` (`listing_id` ASC),
  INDEX `fk_comment_user_idx` (`user_id` ASC),
  CONSTRAINT `fk_comment_listing`
    FOREIGN KEY (`listing_id`) REFERENCES `listing` (`listing_id`)
    ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_comment_user`
    FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`)
    ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='评论留言表';
```

---

## 二、系统功能的数据操作实现方法与结果

### 1. 用户模块

#### 1.1 用户注册

**实现方式**：直接 SQL 插入

**MyBatis Mapper**：
```xml
<insert id="insert" useGeneratedKeys="true" keyProperty="userId">
    INSERT INTO user (student_id, nickname, password, contact_info)
    VALUES (#{studentId}, #{nickname}, #{password}, #{contactInfo})
</insert>
```

**Java Service 代码**：
```java
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserMapper userMapper;

    @Override
    @Transactional
    public User register(UserRegisterDTO dto) {
        // 检查学号是否已存在
        User existing = userMapper.findByStudentId(dto.getStudentId());
        if (existing != null) {
            throw new BusinessException("该学号已被注册");
        }
        
        User user = new User();
        user.setStudentId(dto.getStudentId());
        user.setNickname(dto.getNickname());
        user.setPassword(dto.getPassword()); // 实际应加密
        user.setContactInfo(dto.getContactInfo());
        
        userMapper.insert(user);
        return user;
    }
}
```

**执行结果**：
```json
// 请求
POST /users/register
{
  "studentId": "21371001",
  "nickname": "爱书的同学",
  "password": "password123",
  "contactInfo": "QQ:123456"
}

// 响应
{
  "code": 1,
  "msg": "success",
  "data": {
    "userId": 1,
    "studentId": "21371001"
  }
}
```

#### 1.2 用户登录

**实现方式**：查询验证 + JWT Token 生成

**MyBatis Mapper**：
```xml
<select id="findByStudentId" resultType="com.tiancai.entity.User">
    SELECT user_id AS userId, student_id AS studentId, nickname, 
           password, credit_score AS creditScore, contact_info AS contactInfo
    FROM user 
    WHERE student_id = #{studentId}
</select>
```

**执行结果**：
```json
// 请求
POST /users/login
{
  "studentId": "21371001",
  "password": "password123"
}

// 响应
{
  "code": 1,
  "msg": "success",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userId": 1,
    "nickname": "爱书的同学"
  }
}
```

---

### 2. 书籍与发布模块

#### 2.1 搜索/浏览书籍

**实现方式**：动态 SQL 查询，支持分页、筛选、排序

**MyBatis Mapper**：
```xml
<sql id="filterConditions">
    <where>
        <if test="keyword != null and keyword != ''">
            (b.title LIKE CONCAT('%', #{keyword}, '%') OR
            b.author LIKE CONCAT('%', #{keyword}, '%') OR
            b.isbn LIKE CONCAT('%', #{keyword}, '%'))
        </if>
        <if test="categoryId != null">
            AND EXISTS (
                SELECT 1 FROM book_category bc
                WHERE bc.book_id = b.book_id AND bc.category_id = #{categoryId}
            )
        </if>
        AND l.status = '在售'
    </where>
</sql>

<select id="findPaginatedListings" resultType="com.tiancai.dto.ListingDTO">
    SELECT
        l.listing_id AS listingId,
        b.title, b.author, l.price,
        l.listing_type AS listingType,
        l.status,
        b.cover_image_url AS coverImageUrl,
        u.nickname AS sellerNickname
    FROM listing l
    JOIN book b ON l.book_id = b.book_id
    JOIN `user` u ON l.seller_id = u.user_id
    <include refid="filterConditions"/>
    <choose>
        <when test="sortBy == 'price_asc'">ORDER BY l.price ASC</when>
        <when test="sortBy == 'price_desc'">ORDER BY l.price DESC</when>
        <otherwise>ORDER BY l.post_time DESC</otherwise>
    </choose>
    LIMIT #{pageSize} OFFSET ${(page - 1) * pageSize}
</select>
```

**执行结果**：
```json
// 请求
GET /listings?keyword=数据库&categoryId=1&sortBy=price_asc&page=1&pageSize=10

// 响应
{
  "code": 1,
  "msg": "success",
  "data": {
    "total": 5,
    "page": 1,
    "pageSize": 10,
    "items": [
      {
        "listingId": 1,
        "title": "数据库系统概念",
        "author": "Abraham Silberschatz",
        "price": 35.50,
        "listingType": "出售",
        "status": "在售",
        "coverImageUrl": "https://oss.example.com/db.jpg",
        "sellerNickname": "学霸"
      }
    ]
  }
}
```

#### 2.2 发布新书籍

**实现方式**：事务处理，先检查/创建 Book，再创建 Listing

**Java Service 代码**：
```java
@Override
@Transactional
public Integer create(ListingCreateDTO dto) {
    Integer currentUserId = BaseContext.getCurrentId();
    
    // 1. 检查书籍是否存在，不存在则创建
    Book book = bookMapper.findByIsbn(dto.getIsbn());
    if (book == null) {
        book = new Book();
        book.setIsbn(dto.getIsbn());
        book.setTitle(dto.getTitle());
        book.setAuthor(dto.getAuthor());
        book.setPublisher(dto.getPublisher());
        book.setPublicationYear(dto.getPublicationYear());
        book.setCoverImageUrl(dto.getCoverImageUrl());
        bookMapper.insert(book);
    }
    
    // 2. 创建发布信息
    Listing listing = new Listing();
    listing.setSellerId(currentUserId);
    listing.setBookId(book.getBookId());
    listing.setPrice(dto.getPrice());
    listing.setConditionDesc(dto.getCondition());
    listing.setListingType(dto.getListingType());
    listing.setDescription(dto.getDescription());
    
    bookAndListingMapper.insert(listing);
    
    // 3. 关联书籍分类
    if (dto.getCategoryId() != null) {
        bookCategoryMapper.insertBookCategory(book.getBookId(), dto.getCategoryId());
    }
    
    return listing.getListingId();
}
```

**执行结果**：
```json
// 请求
POST /listings
{
  "isbn": "9787111216719",
  "title": "数据库系统概念",
  "author": "Abraham Silberschatz",
  "price": 35.50,
  "condition": "九成新",
  "listingType": "出售",
  "categoryId": 1
}

// 响应
{
  "code": 1,
  "msg": "success",
  "data": { "listingId": 1 }
}
```

---

### 3. 订单模块

#### 3.1 创建订单（触发器自动更新书籍状态）

**触发器定义**：
```sql
CREATE TRIGGER after_order_insert
AFTER INSERT ON `orders`
FOR EACH ROW
BEGIN
    UPDATE `listing`
    SET `status` = '已预定'
    WHERE listing_id = NEW.listing_id;
END$$
```

**Java Service 代码**：
```java
@Override
@Transactional
public Integer createOrder(OrderCreateDTO dto) {
    Integer currentUserId = BaseContext.getCurrentId();
    
    // 检查书籍是否在售
    Listing listing = bookAndListingMapper.findById(dto.getListingId());
    if (listing == null) {
        throw new ResourceNotFoundException("书籍不存在");
    }
    if (!"在售".equals(listing.getStatus())) {
        throw new BusinessException("该书籍已被预定或已售出");
    }
    if (listing.getSellerId().equals(currentUserId)) {
        throw new BusinessException("不能购买自己发布的书籍");
    }
    
    // 创建订单（触发器会自动更新 listing 状态为"已预定"）
    Order order = new Order();
    order.setListingId(dto.getListingId());
    order.setBuyerId(currentUserId);
    order.setTransactionPrice(listing.getPrice());
    
    orderMapper.insert(order);
    return order.getOrderId();
}
```

**执行结果**：
```
1. 订单创建成功，order_id = 1
2. 触发器自动执行，listing.status 从 '在售' 变为 '已预定'
```

#### 3.2 确认交易完成（存储过程 + 触发器）

**存储过程定义**：
```sql
CREATE PROCEDURE complete_transaction(
    IN p_order_id INT,
    OUT p_result_code INT,
    OUT p_result_message VARCHAR(255)
)
BEGIN
    DECLARE current_order_status VARCHAR(50) DEFAULT NULL;
    DECLARE target_listing_id INT DEFAULT NULL;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result_code = 2;
        SET p_result_message = '操作失败：发生未知数据库错误。';
    END;

    -- 查询订单信息
    SELECT order_status, listing_id 
    INTO current_order_status, target_listing_id
    FROM `orders` 
    WHERE order_id = p_order_id
    LIMIT 1;

    IF current_order_status IS NULL THEN
        SET p_result_code = 1;
        SET p_result_message = '操作失败：订单不存在。';
    ELSEIF current_order_status != '待确认' THEN
        SET p_result_code = 1;
        SET p_result_message = CONCAT('操作失败：订单当前状态为 "', current_order_status, '"，无法完成。');
    ELSE
        START TRANSACTION;

        -- 1. 更新订单状态为"已完成"
        UPDATE `orders` SET order_status = '已完成' WHERE order_id = p_order_id;

        -- 2. 更新发布信息状态为"已售出"
        UPDATE `listing` SET `status` = '已售出' WHERE listing_id = target_listing_id;
        
        -- 3. 信誉分更新由触发器自动完成

        COMMIT;
        SET p_result_code = 0;
        SET p_result_message = '交易成功完成！';
    END IF;
END$$
```

**触发器定义（自动增加信誉分）**：
```sql
CREATE TRIGGER after_order_update_complete
AFTER UPDATE ON `orders`
FOR EACH ROW
BEGIN
    DECLARE seller_user_id INT;

    IF OLD.order_status != '已完成' AND NEW.order_status = '已完成' THEN
        -- 获取卖家ID
        SELECT seller_id INTO seller_user_id 
        FROM `listing` WHERE listing_id = NEW.listing_id;

        -- 给买家增加信誉分（+5分）
        UPDATE `user` SET credit_score = credit_score + 5 WHERE user_id = NEW.buyer_id;

        -- 给卖家增加信誉分（+5分）
        UPDATE `user` SET credit_score = credit_score + 5 WHERE user_id = seller_user_id;
    END IF;
END$$
```

**MyBatis 调用存储过程**：
```xml
<select id="completeTransaction" statementType="CALLABLE" parameterType="map">
    {CALL complete_transaction(
        #{orderId, mode=IN, jdbcType=INTEGER},
        #{resultCode, mode=OUT, jdbcType=INTEGER},
        #{resultMessage, mode=OUT, jdbcType=VARCHAR}
    )}
</select>
```

**执行结果**：
```
1. 存储过程执行：订单状态从 '待确认' 变为 '已完成'
2. 存储过程执行：书籍状态从 '已预定' 变为 '已售出'
3. 触发器自动执行：买家信誉分 +5
4. 触发器自动执行：卖家信誉分 +5
```

#### 3.3 取消订单（触发器自动恢复书籍状态）

**触发器定义**：
```sql
CREATE TRIGGER after_order_update_cancel
AFTER UPDATE ON `orders`
FOR EACH ROW
BEGIN
    IF NEW.order_status = '已取消' THEN
        UPDATE `listing`
        SET `status` = '在售'
        WHERE listing_id = NEW.listing_id;
    END IF;
END$$
```

**执行结果**：
```
1. 订单状态更新为 '已取消'
2. 触发器自动执行，listing.status 从 '已预定' 恢复为 '在售'
```

---

### 4. 分类模块

#### 4.1 获取所有分类

**MyBatis Mapper**：
```xml
<select id="findAllCategories" resultType="com.tiancai.entity.Category">
    SELECT category_id AS categoryId, category_name AS categoryName
    FROM category
    ORDER BY category_id
</select>
```

**执行结果**：
```json
{
  "code": 1,
  "msg": "success",
  "data": [
    { "categoryId": 1, "categoryName": "计算机" },
    { "categoryId": 2, "categoryName": "文学小说" },
    { "categoryId": 3, "categoryName": "外语学习" },
    { "categoryId": 4, "categoryName": "考研考公" },
    { "categoryId": 5, "categoryName": "理工科" }
  ]
}
```

---

### 5. 数据库高级特性使用总结

| 特性 | 使用场景 | 具体实现 |
|-----|---------|---------|
| **触发器** | 创建订单后自动更新书籍状态 | `after_order_insert` |
| **触发器** | 交易完成后自动增加信誉分 | `after_order_update_complete` |
| **触发器** | 取消订单后自动恢复书籍状态 | `after_order_update_cancel` |
| **存储过程** | 完成交易的原子操作 | `complete_transaction` |
| **事务** | 发布书籍（Book + Listing + Category 关联） | Spring `@Transactional` |
| **外键约束** | 保证数据参照完整性 | 所有关联表 |
| **唯一索引** | 防止重复数据 | `student_id`, `isbn`, `category_name` |

---

## 三、组员大作业总结

### 同学1：

**任务内容概述**：
负责系统功能设计与用户模块、订单模块的数据库操作实现。主要工作包括：
1. 系统整体功能模块划分和 API 接口设计
2. 用户注册、登录、信息管理功能的实现
3. 订单创建、查询、确认、取消功能的实现
4. 编写触发器和存储过程实现业务逻辑自动化

**任务难点及解决方法**：
1. **难点**：订单状态变更需要联动更新书籍状态和用户信誉分
   - **解决**：使用触发器（Trigger）实现自动化联动，当订单状态变更时自动触发相关更新操作

2. **难点**：交易完成需要保证原子性
   - **解决**：使用存储过程（Stored Procedure）封装事务，确保订单更新和书籍状态更新在同一事务中完成

3. **难点**：用户认证和权限控制
   - **解决**：使用 JWT Token 实现无状态认证，通过拦截器统一验证用户身份

**任务完成结果**：
- 成功实现用户模块的全部功能（注册、登录、信息查询和修改）
- 成功实现订单模块的全部功能（下单、查询、确认、取消）
- 成功编写 3 个触发器和 1 个存储过程
- 所有 API 接口测试通过

**收获与体会**：
通过本次大作业，深入理解了数据库触发器和存储过程的实际应用场景。触发器可以实现业务逻辑的自动化，减少应用层代码的复杂度；存储过程可以封装复杂的事务操作，保证数据一致性。同时也掌握了 Spring Boot + MyBatis 框架的开发流程，对前后端分离架构有了更深入的理解。

---

### 同学2：

**任务内容概述**：
负责系统数据库设计与书籍发布模块的数据库操作实现。主要工作包括：
1. 数据库概念模式设计（E-R 图）
2. 数据库逻辑模式设计（关系模式定义和范式分析）
3. 数据库物理设计（索引设计）
4. 书籍搜索、详情查看、发布、下架功能的实现

**任务难点及解决方法**：
1. **难点**：书籍搜索需要支持多条件组合查询
   - **解决**：使用 MyBatis 动态 SQL（`<if>`, `<where>`, `<choose>`）实现灵活的条件组合

2. **难点**：书籍与分类是多对多关系，查询时需要高效关联
   - **解决**：使用中间表 `book_category` 实现多对多关联，并通过子查询优化分类筛选

3. **难点**：发布书籍时需要处理书籍去重（同一 ISBN 的书不重复创建）
   - **解决**：先根据 ISBN 查询，存在则复用，不存在则新建，使用事务保证原子性

**任务完成结果**：
- 完成了完整的数据库设计文档（E-R 图、关系模式、范式分析）
- 成功创建 7 张数据库表，包含主键、外键、索引约束
- 成功实现书籍搜索、详情、发布、下架功能
- 支持关键词搜索、分类筛选、价格排序、分页查询

**收获与体会**：
通过本次大作业，系统地学习了数据库设计的完整流程：从需求分析到概念设计，再到逻辑设计和物理设计。深刻理解了范式化设计的重要性，以及如何在规范化和查询效率之间做权衡。同时掌握了 MyBatis 动态 SQL 的编写技巧，能够实现复杂的多条件查询。前端 Vue.js + Element Plus 的开发也让我对全栈开发有了更全面的认识。

---

## 附录：项目技术栈

| 层次 | 技术 |
|-----|------|
| 前端 | Vue 3 + Element Plus + Vite + Pinia + Axios |
| 后端 | Spring Boot 3 + MyBatis + JWT |
| 数据库 | MySQL 8 (InnoDB) |
| 对象存储 | 阿里云 OSS |
| 开发工具 | IntelliJ IDEA, VS Code, Navicat |

